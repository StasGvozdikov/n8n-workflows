// Отримуємо вхідні дані від n8n.
// Очікується, що це масив об'єктів, де кожен об'єкт має властивість 'json' з даними одного тендеру.
const tenders = items.map(item => item.json);

// Створюємо порожній масив для зберігання оброблених результатів.
const processedResults =;

// Перебираємо кожен тендер, отриманий з попереднього вузла.
for (const tender of tenders) {
  // --- Етап 1: Підготовка даних про переможців (Awards) ---

  // Використовуємо опціональний ланцюжок (?.) та оператор нульового злиття (??)
  // для безпечного отримання масиву нагороджень. Якщо 'tender.awards' не існує,
  // ми отримаємо порожній масив, що запобігає помилкам.
  const awards = tender.awards??;

  // Фільтруємо нагородження, щоб залишити тільки ті, що мають статус 'active'.
  // Це єдиний надійний спосіб визначити поточного переможця.
  const activeAwards = awards.filter(a => a.status === 'active');

  // Створюємо карту (lookup map) для швидкого доступу до даних про переможця за ID лота.
  // Це набагато ефективніше, ніж шукати потрібне нагородження в циклі для кожного товару.
  const awardMap = activeAwards.reduce((acc, award) => {
    // Ключем є ID лота. Якщо lotID відсутній (для однолотових тендерів),
    // використовуємо 'default' як ключ.
    const key = award.lotID |

| 'default';
    acc[key] = {
      supplier: award.suppliers?.?.name?? 'Не визначено',
      price: award.value?.amount?? null,
      currency: award.value?.currency?? null,
      awardDate: award.date?? null
    };
    return acc;
  }, {});

  // --- Етап 2: Підготовка даних про контракти (Contracts) ---

  // Аналогічно до нагороджень, створюємо карту для контрактів.
  // Це потрібно для отримання точної дати підписання контракту.
  const contracts = tender.contracts??;
  const contractMap = contracts.reduce((acc, contract) => {
    // Шукаємо пов'язане нагородження, щоб отримати ID лота.
    const relatedAward = awards.find(a => a.id === contract.awardID);
    if (relatedAward) {
      const key = relatedAward.lotID |

| 'default';
      acc[key] = {
        contractDate: contract.dateSigned?? null
      };
    }
    return acc;
  }, {});

  // --- Етап 3: Обробка товарних позицій (Items) ---

  // Перевіряємо, чи існує масив товарів у тендері.
  if (tender.items && tender.items.length > 0) {
    // Перебираємо кожну товарну позицію в тендері.
    for (const item of tender.items) {
      // Визначаємо ключ для пошуку в картах. Для багатолотових тендерів це 'item.relatedLot'.
      // Для однолотових, де 'relatedLot' може бути відсутнім, використовуємо 'default'.
      // Це дозволяє уніфікувати логіку.
      const lotKey = item.relatedLot |

| 'default';

      // Отримуємо дані про переможця та контракт з наших карт.
      const winningAward = awardMap[lotKey];
      const signedContract = contractMap[lotKey];

      // Створюємо новий "плаский" об'єкт з усіма потрібними даними.
      const resultItem = {
        resourceName: item.description?? 'Опис відсутній',
        price: winningAward?.price?? tender.value?.amount?? null, // Ціна з нагородження, або очікувана вартість як fallback
        unit: item.unit?.name?? 'Не вказано',
        supplier: winningAward?.supplier?? 'Не визначено',
        // Дата контракту є пріоритетною. Якщо її немає, беремо дату нагородження.
        contractDate: signedContract?.contractDate?? winningAward?.awardDate?? null,
        region: item.deliveryAddress?.region?? tender.procuringEntity?.address?.region?? 'Не вказано',
        tenderLink: `https://prozorro.gov.ua/tender/${tender.tenderID}`
      };

      // Додаємо оброблений об'єкт до масиву результатів.
      processedResults.push(resultItem);
    }
  }
}

// Повертаємо результат у форматі, який очікує n8n.
// Кожен об'єкт у масиві 'processedResults' загортається в { json:... }.
return processedResults.map(item => ({ json: item }));
